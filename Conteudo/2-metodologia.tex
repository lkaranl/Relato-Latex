\section{MATERIAIS E MÉTODOS / PROCEDIMENTOS METODOLÓGICOS}
    Para a infraestrutura do experimento, escolhemos o microcontrolador \emph{M5StickC} devido à sua portabilidade e baixo consumo energético. Esse dispositivo, equipado com o SoC \emph{ESP32-PICO-D4}, nos ofereceu a arquitetura dual-core necessária (240\,MHz), 
    520 KB de SRAM, conectividade Wi‑Fi (802.11 b/g/n) e 4 MB de memória \emph{flash} \cite{esp32_pico_datasheet}.
        
    O dispositivo possui uma tela TFT de 0{,}96$''$ com resolução de 80×160 pixels (driver ST7735SV), e é alimentado por uma bateria interna Li‑Po de 95 mAh a 3{,}7 V, gerenciada pelo circuito PMIC \emph{AXP192}, responsável também por fornecer energia aos demais componentes internos \cite{m5stickc_doc}.
    
    O \emph{M5StickC} integra diversos sensores e periféricos: IMU \emph{MPU6886}, microfone digital \emph{SPM1423}, LED vermelho, emissor infravermelho (IR), relógio de tempo real \emph{BM8563}, buzzer, dois botões físicos e antena de 2{,}4 GHz \cite{m5stickc_doc}. Para comunicação e expansão, disponibiliza uma porta Grove e os pinos G0, G26 e G36. Suas dimensões são de aproximadamente 48{,}2 × 25{,}5 × 13{,}7 mm, com peso de cerca de 15{,}1 g e faixa de temperatura de operação entre 0 °C e 60 °C \cite{digi_m5stickc}.

    \subsection{Implementação do WIFI}
    Nesta seção, detalhamos os procedimentos que adotamos para criar e operar o ponto de acesso Wi-Fi falso. Descrevemos desde a configuração inicial do dispositivo até os desafios técnicos que enfrentamos e superamos durante a execução.
    
    \subsubsection{Configuração do Ambiente}
       Configuramos o \emph{M5StickC} para atuar como ponto de acesso (\emph{access point}) utilizando um firmware personalizado na plataforma ESP32-Arduino \cite{m5stickc_doc}. Apesar do dispositivo possuir um \emph{captive portal} nativo, optamos por modificar o firmware para garantir que todas as requisições HTTP fossem redirecionadas para o nosso servidor local. Isso nos permitiu exibir uma réplica fiel da tela de login do Facebook (ver Figura~\ref{fig:loginfacebook}), que projetamos para ser visualmente idêntica à original e capaz de capturar as credenciais (e-mail e senha) inseridas pelos participantes.

   \begin{figure}[ht]
      \centering
      \includegraphics[width=0.8\linewidth]{img/login_facebook.png}
      \caption{Tela falsa de login do Facebook utilizada no experimento.}
      \label{fig:loginfacebook}
    \end{figure}

    Durante nossos testes de campo, percebemos que a antena integrada possuía um alcance limitado (cerca de 10\,m). Chegamos a cogitar o uso de roteadores como repetidores, mas descartamos a ideia pois o redirecionamento para o portal falso falhava nessa configuração. Nossa solução foi posicionar o \emph{M5StickC} manualmente em pontos estratégicos de circulação, o que nos permitiu maximizar o alcance efetivo da rede.
    
    Também enfrentamos o desafio da autonomia energética. A bateria interna sustentava o dispositivo por apenas 5 a 8 minutos, o que inviabilizava nossa proposta. Para resolver isso, acoplamos uma bateria externa (\emph{power bank}) de 4000\,mAh, garantindo a execução contínua do experimento durante todo o período planejado.

    Preocupados com a privacidade e a ética da pesquisa, implementamos um rigoroso processo de anonimização. Nenhuma credencial real foi armazenada em texto claro; nosso procedimento de registro e anonimização está detalhado no Algoritmo~\ref{alg:anonimizacao}.

    \begin{algorithm}[H]
    \caption{Anonimização e Registro de Tentativas de Login}
    \label{alg:anonimizacao}
    \begin{algorithmic}[1]
        \Require \textit{email}, \textit{senha}
        \Ensure Dados anonimizados registrados em arquivo JSON
        
        \State \textit{domínio} $\gets$ parte após `@` em \textit{email}
        \State \textit{emailAnon} $\gets$ primeiros 2 caracteres de \textit{email} $+ \text{``****@''} +$ \textit{domínio}
        \State \textit{senhaTam} $\gets$ comprimento de \textit{senha}
        \State \textit{timestamp} $\gets$ data e hora atual
        
        \State \textit{dados} $\gets$ \{email: \textit{emailAnon}, senha\_tamanho: \textit{senhaTam}, timestamp: \textit{timestamp}\}
        
        \If{arquivo \texttt{credenciais\_anonimas.json} existe}
            \State \textit{logs} $\gets$ conteúdo do arquivo em JSON
        \Else
            \State \textit{logs} $\gets$ lista vazia
        \EndIf
        
        \State Adicionar \textit{dados} à lista \textit{logs}
        \State Salvar \textit{logs} no arquivo \texttt{credenciais\_anonimas.json} em formato JSON
        
        \State Marcar erro de login na sessão
        \State Redirecionar usuário para \texttt{index.php}
    \end{algorithmic}
\end{algorithm}

    O algoritmo inicia com a extração do domínio do e-mail informado e a anonimização parcial do endereço, mantendo apenas os dois primeiros caracteres seguidos por asteriscos e o domínio original. Em seguida, registra-se o tamanho da senha (sem armazenar seu conteúdo) e um \emph{timestamp} com data e hora da tentativa. Esses dados são organizados em um objeto JSON e inseridos em um arquivo local, preservando tentativas anteriores. Caso o arquivo já exista, ele é carregado e atualizado com a nova entrada. Por fim, a tentativa é marcada como falha na sessão e o usuário é redirecionado à página inicial, mantendo a simulação de erro de login e evitando suspeitas por parte da vítima.
